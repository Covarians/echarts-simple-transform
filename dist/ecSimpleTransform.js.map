{"version":3,"file":"ecSimpleTransform.js","sources":["../src/id.ts","../src/util.ts","../src/aggregate.ts","../src/map.ts"],"sourcesContent":["/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\nimport {\r\n    DataTransformOption, DimensionDefinitionLoose, DimensionIndex,\r\n    DimensionName, ExternalDataTransform, OptionSourceDataArrayRows\r\n} from './types';\r\n\r\n/**\r\n * @usage\r\n *\r\n * ```js\r\n * dataset: [{\r\n *     source: [\r\n *         ['aa', 'bb', 'cc', 'tag'],\r\n *         [12, 0.33, 5200, 'AA'],\r\n *         [21, 0.65, 8100, 'AA'],\r\n *         ...\r\n *     ]\r\n * }, {\r\n *     transform: {\r\n *         type: 'ecSimpleTransform:id',\r\n *         config: {\r\n *             dimensionIndex: 4,\r\n *             dimensionName: 'ID'\r\n *         }\r\n *     }\r\n *     // Then the result data will be:\r\n *     // [\r\n *     //     ['aa', 'bb', 'cc', 'tag', 'ID'],\r\n *     //     [12, 0.33, 5200, 'AA', 0],\r\n *     //     [21, 0.65, 8100, 'BB', 1],\r\n *     //     ...\r\n *     // ]\r\n * }]\r\n * ```\r\n */\r\n\r\nexport interface IdTransformOption extends DataTransformOption {\r\n    type: 'ecSimpleTransform:id';\r\n    config: {\r\n        // Mandatory. Specify where to put the new id dimension.\r\n        dimensionIndex: DimensionIndex;\r\n        // Optional. If not provided, left the dimension name not defined.\r\n        dimensionName: DimensionName;\r\n    };\r\n}\r\n\r\nexport const transform: ExternalDataTransform<IdTransformOption> = {\r\n\r\n    type: 'ecSimpleTransform:id',\r\n\r\n    transform: function (params) {\r\n        const upstream = params.upstream;\r\n        const config = params.config;\r\n        const dimensionIndex = config.dimensionIndex;\r\n        const dimensionName = config.dimensionName;\r\n\r\n        const dimsDef = upstream.cloneAllDimensionInfo() as DimensionDefinitionLoose[];\r\n        dimsDef[dimensionIndex] = dimensionName;\r\n\r\n        const data = upstream.cloneRawData() as OptionSourceDataArrayRows;\r\n\r\n        // TODO: support objectRows\r\n        for (let i = 0, len = data.length; i < len; i++) {\r\n            const line = data[i];\r\n            line[dimensionIndex] = i;\r\n        }\r\n\r\n        return {\r\n            dimensions: dimsDef,\r\n            data: data\r\n        };\r\n    }\r\n};\r\n","/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\nexport function assert(condition: any, message?: string) {\r\n    if (!condition) {\r\n        throw new Error(message);\r\n    }\r\n}\r\n\r\nexport function hasOwn(own: object, prop: string): boolean {\r\n    return own.hasOwnProperty(prop);\r\n}\r\n\r\nexport function quantile(ascArr: number[], p: number): number {\r\n    const H = (ascArr.length - 1) * p + 1;\r\n    const h = Math.floor(H);\r\n    const v = +ascArr[h - 1];\r\n    const e = H - h;\r\n    return e ? v + e * (ascArr[h] - v) : v;\r\n}\r\n","/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\nimport {\r\n    DataTransformOption, DimensionLoose, DimensionName, ExternalDataTransform,\r\n    ExternalDimensionDefinition, ExternalSource, OptionDataValue\r\n} from './types';\r\nimport { assert, hasOwn, quantile } from './util';\r\n\r\n/**\r\n * @usage\r\n *\r\n * ```js\r\n * dataset: [{\r\n *     source: [\r\n *         ['aa', 'bb', 'cc', 'tag'],\r\n *         [12, 0.33, 5200, 'AA'],\r\n *         [21, 0.65, 7100, 'AA'],\r\n *         [51, 0.15, 1100, 'BB'],\r\n *         [71, 0.75, 9100, 'BB'],\r\n *         ...\r\n *     ]\r\n * }, {\r\n *     transform: {\r\n *         type: 'ecSimpleTransform:aggregate',\r\n *         config: {\r\n *             resultDimensions: [\r\n *                 // by default, use the same name with `from`.\r\n *                 { from: 'aa', method: 'sum' },\r\n *                 { from: 'bb', method: 'count' },\r\n *                 { from: 'cc' }, // method by default: use the first value.\r\n *                 { from: 'dd', method: 'Q1' },\r\n *                 { from: 'tag' }\r\n *             ],\r\n *             groupBy: 'tag'\r\n *         }\r\n *     }\r\n *     // Then the result data will be:\r\n *     // [\r\n *     //     ['aa', 'bb', 'cc', 'tag'],\r\n *     //     [12, 0.33, 5200, 'AA'],\r\n *     //     [21, 0.65, 8100, 'BB'],\r\n *     //     ...\r\n *     // ]\r\n * }]\r\n * ```\r\n */\r\n\r\nexport interface AggregateTransformOption extends DataTransformOption {\r\n    type: 'ecSimpleTransform:aggregate';\r\n    config: {\r\n        // Mandatory\r\n        resultDimensions: {\r\n            // Optional. The name of the result dimensions.\r\n            // If not provided, inherit the name from `from`.\r\n            name: DimensionName;\r\n            // Mandatory. `from` is used to reference dimension from `source`.\r\n            from: DimensionLoose;\r\n            // Optional. Aggregate method. Currently only these method supported.\r\n            // If not provided, use `'first'`.\r\n            method: AggregateMethodLoose;\r\n        }[];\r\n        // Optional\r\n        groupBy: DimensionLoose;\r\n    };\r\n}\r\n\r\nconst METHOD_INTERNAL = {\r\n    'SUM': true,\r\n    'COUNT': true,\r\n    'FIRST': true,\r\n    'AVERAGE': true,\r\n    'Q1': true,\r\n    'Q2': true,\r\n    'Q3': true,\r\n    'MIN': true,\r\n    'MAX': true\r\n} as const;\r\nconst METHOD_NEEDS_COLLECT = {\r\n    AVERAGE: ['COUNT']\r\n} as const;\r\nconst METHOD_NEEDS_GATHER_VALUES = {\r\n    Q1: true,\r\n    Q2: true,\r\n    Q3: true\r\n} as const;\r\nconst METHOD_ALIAS = {\r\n    MEDIAN: 'Q2'\r\n} as const;\r\n\r\ntype AggregateMethodLoose =\r\n    AggregateMethodInternal\r\n    | 'sum' | 'count' | 'first' | 'average' | 'Q1' | 'Q2' | 'Q3' | 'median' | 'min' | 'max';\r\ntype AggregateMethodInternal = keyof typeof METHOD_INTERNAL;\r\n\r\n\r\nclass ResultDimInfoInternal {\r\n\r\n    readonly method: AggregateMethodInternal;\r\n    readonly name: DimensionName;\r\n    readonly index: number;\r\n    readonly indexInUpstream: number;\r\n\r\n    readonly collectionInfoList = [] as {\r\n        method: AggregateMethodInternal;\r\n        indexInLine: number;\r\n    }[];\r\n\r\n    // FIXME: refactor\r\n    readonly gatheredValuesByGroup: { [groupVal: string]: number[] } = {};\r\n    readonly gatheredValuesNoGroup = [] as number[];\r\n    readonly needGatherValues: boolean = false;\r\n\r\n    __collectionResult: TravelResult<CollectionResultLine>;\r\n\r\n    private _collectionInfoMap = {} as {\r\n        // number is the index of `list`\r\n        [method in AggregateMethodInternal]: number\r\n    };\r\n\r\n    constructor(\r\n        index: number,\r\n        indexInUpstream: number,\r\n        method: AggregateMethodInternal,\r\n        name: DimensionName,\r\n        needGatherValues: boolean\r\n    ) {\r\n        this.method = method;\r\n        this.name = name;\r\n        this.index = index;\r\n        this.indexInUpstream = indexInUpstream;\r\n        this.needGatherValues = needGatherValues;\r\n    }\r\n\r\n    addCollectionInfo(item: ResultDimInfoInternal['collectionInfoList'][number]) {\r\n        this._collectionInfoMap[item.method] = this.collectionInfoList.length;\r\n        this.collectionInfoList.push(item);\r\n    }\r\n\r\n    getCollectionInfo(method: AggregateMethodInternal) {\r\n        return this.collectionInfoList[this._collectionInfoMap[method]];\r\n    }\r\n\r\n    // FIXME: temp implementation. Need refactor.\r\n    gatherValue(groupByDimInfo: ExternalDimensionDefinition, groupVal: OptionDataValue, value: OptionDataValue) {\r\n        // FIXME: convert to number compulsorily temporarily.\r\n        value = +value;\r\n        if (groupByDimInfo) {\r\n            if (groupVal != null) {\r\n                const groupValStr = groupVal + '';\r\n                const values = this.gatheredValuesByGroup[groupValStr]\r\n                    || (this.gatheredValuesByGroup[groupValStr] = []);\r\n                values.push(value);\r\n            }\r\n        }\r\n        else {\r\n            this.gatheredValuesNoGroup.push(value);\r\n        }\r\n    }\r\n}\r\n\r\ntype CreateInTravel<LINE> = (\r\n    upstream: ExternalSource,\r\n    dataIndex: number,\r\n    dimInfoList: ResultDimInfoInternal[],\r\n    groupByDimInfo?: ExternalDimensionDefinition,\r\n    groupByVal?: OptionDataValue\r\n) => LINE;\r\ntype UpdateInTravel<LINE> = (\r\n    upstream: ExternalSource,\r\n    dataIndex: number,\r\n    targetLine: LINE,\r\n    dimInfoList: ResultDimInfoInternal[],\r\n    groupByDimInfo?: ExternalDimensionDefinition,\r\n    groupByVal?: OptionDataValue\r\n) => void;\r\n\r\nexport const transform: ExternalDataTransform<AggregateTransformOption> = {\r\n\r\n    type: 'ecSimpleTransform:aggregate',\r\n\r\n    transform: function (params) {\r\n        const upstream = params.upstream;\r\n        const config = params.config;\r\n\r\n        const groupByDimInfo = prepareGroupByDimInfo(config, upstream);\r\n        const { finalResultDimInfoList, collectionDimInfoList } = prepareDimensions(\r\n            config, upstream, groupByDimInfo\r\n        );\r\n\r\n        // Collect\r\n        let collectionResult: TravelResult<CollectionResultLine>;\r\n        if (collectionDimInfoList.length) {\r\n            collectionResult = travel(\r\n                groupByDimInfo,\r\n                upstream,\r\n                collectionDimInfoList,\r\n                createCollectionResultLine,\r\n                updateCollectionResultLine\r\n            );\r\n        }\r\n\r\n        for (let i = 0; i < collectionDimInfoList.length; i++) {\r\n            const dimInfo = collectionDimInfoList[i];\r\n            dimInfo.__collectionResult = collectionResult;\r\n            // FIXME: just for Q1, Q2, Q3: need asc.\r\n            asc(dimInfo.gatheredValuesNoGroup);\r\n\r\n            const gatheredValuesByGroup = dimInfo.gatheredValuesByGroup;\r\n            for (const key in gatheredValuesByGroup) {\r\n                if (hasOwn(gatheredValuesByGroup, key)) {\r\n                    asc(gatheredValuesByGroup[key]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Calculate\r\n        const finalResult = travel(\r\n            groupByDimInfo,\r\n            upstream,\r\n            finalResultDimInfoList,\r\n            createFinalResultLine,\r\n            updateFinalResultLine\r\n        );\r\n\r\n        const dimensions = [];\r\n        for (let i = 0; i < finalResultDimInfoList.length; i++) {\r\n            dimensions.push(finalResultDimInfoList[i].name);\r\n        }\r\n\r\n        return {\r\n            dimensions: dimensions,\r\n            data: finalResult.outList\r\n        };\r\n    }\r\n};\r\n\r\nfunction prepareDimensions(\r\n    config: AggregateTransformOption['config'],\r\n    upstream: ExternalSource,\r\n    groupByDimInfo: ExternalDimensionDefinition\r\n): {\r\n    finalResultDimInfoList: ResultDimInfoInternal[];\r\n    collectionDimInfoList: ResultDimInfoInternal[];\r\n} {\r\n    const resultDimensionsConfig = config.resultDimensions;\r\n    const finalResultDimInfoList: ResultDimInfoInternal[] = [];\r\n    const collectionDimInfoList: ResultDimInfoInternal[] = [];\r\n    let gIndexInLine = 0;\r\n\r\n    for (let i = 0; i < resultDimensionsConfig.length; i++) {\r\n        const resultDimInfoConfig = resultDimensionsConfig[i];\r\n\r\n        const dimInfoInUpstream = upstream.getDimensionInfo(resultDimInfoConfig.from);\r\n        assert(dimInfoInUpstream, 'Can not find dimension by `from`: ' + resultDimInfoConfig.from);\r\n\r\n        const rawMethod = resultDimInfoConfig.method;\r\n\r\n        assert(\r\n            groupByDimInfo.index !== dimInfoInUpstream.index || rawMethod == null,\r\n            `Dimension ${dimInfoInUpstream.name} is the \"groupBy\" dimension, must not have any \"method\".`\r\n        );\r\n\r\n        const method = normalizeMethod(rawMethod);\r\n        assert(method, 'method is required');\r\n\r\n        const name = resultDimInfoConfig.name != null ? resultDimInfoConfig.name : dimInfoInUpstream.name;\r\n\r\n        const finalResultDimInfo = new ResultDimInfoInternal(\r\n            finalResultDimInfoList.length,\r\n            dimInfoInUpstream.index,\r\n            method,\r\n            name,\r\n            hasOwn(METHOD_NEEDS_GATHER_VALUES, method)\r\n        );\r\n        finalResultDimInfoList.push(finalResultDimInfo);\r\n\r\n        // For collection.\r\n        let needCollect = false;\r\n        if (hasOwn(METHOD_NEEDS_COLLECT, method)) {\r\n            needCollect = true;\r\n            const collectionTargetMethods = METHOD_NEEDS_COLLECT[method as keyof typeof METHOD_NEEDS_COLLECT];\r\n            for (let j = 0; j < collectionTargetMethods.length; j++) {\r\n                finalResultDimInfo.addCollectionInfo({\r\n                    method: collectionTargetMethods[j],\r\n                    indexInLine: gIndexInLine++\r\n                });\r\n            }\r\n        }\r\n        if (hasOwn(METHOD_NEEDS_GATHER_VALUES, method)) {\r\n            needCollect = true;\r\n        }\r\n        if (needCollect) {\r\n            collectionDimInfoList.push(finalResultDimInfo);\r\n        }\r\n    }\r\n\r\n    return { collectionDimInfoList, finalResultDimInfoList };\r\n}\r\n\r\nfunction prepareGroupByDimInfo(\r\n    config: AggregateTransformOption['config'],\r\n    upstream: ExternalSource\r\n): ExternalDimensionDefinition {\r\n    const groupByConfig = config.groupBy;\r\n    let groupByDimInfo;\r\n    if (groupByConfig != null) {\r\n        groupByDimInfo = upstream.getDimensionInfo(groupByConfig);\r\n        assert(groupByDimInfo, 'Can not find dimension by `groupBy`: ' + groupByConfig);\r\n    }\r\n    return groupByDimInfo;\r\n}\r\n\r\ninterface TravelResult<LINE> {\r\n    mapByGroup: { [groupVal: string]: LINE };\r\n    outList: LINE[];\r\n}\r\n\r\nfunction travel<LINE>(\r\n    groupByDimInfo: ExternalDimensionDefinition,\r\n    upstream: ExternalSource,\r\n    resultDimInfoList: ResultDimInfoInternal[],\r\n    doCreate: CreateInTravel<LINE>,\r\n    doUpdate: UpdateInTravel<LINE>\r\n): TravelResult<LINE> {\r\n    const outList: TravelResult<LINE>['outList'] = [];\r\n    let mapByGroup: TravelResult<LINE>['mapByGroup'];\r\n\r\n    if (groupByDimInfo) {\r\n        mapByGroup = {};\r\n\r\n        for (let dataIndex = 0, len = upstream.count(); dataIndex < len; dataIndex++) {\r\n            const groupByVal = upstream.retrieveValue(dataIndex, groupByDimInfo.index);\r\n\r\n            // PENDING: when value is null/undefined\r\n            if (groupByVal == null) {\r\n                continue;\r\n            }\r\n\r\n            const groupByValStr = groupByVal + '';\r\n\r\n            if (!hasOwn(mapByGroup, groupByValStr)) {\r\n                const newLine = doCreate(upstream, dataIndex, resultDimInfoList, groupByDimInfo, groupByVal);\r\n                outList.push(newLine);\r\n                mapByGroup[groupByValStr] = newLine;\r\n            }\r\n            else {\r\n                const targetLine = mapByGroup[groupByValStr];\r\n                doUpdate(upstream, dataIndex, targetLine, resultDimInfoList, groupByDimInfo, groupByVal);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const targetLine = doCreate(upstream, 0, resultDimInfoList);\r\n        outList.push(targetLine);\r\n        for (let dataIndex = 1, len = upstream.count(); dataIndex < len; dataIndex++) {\r\n            doUpdate(upstream, dataIndex, targetLine, resultDimInfoList);\r\n        }\r\n    }\r\n\r\n    return { mapByGroup, outList };\r\n}\r\n\r\nfunction normalizeMethod(method: AggregateMethodLoose): AggregateMethodInternal {\r\n    if (method == null) {\r\n        return 'FIRST';\r\n    }\r\n    let methodInternal = method.toUpperCase() as AggregateMethodInternal;\r\n    methodInternal = hasOwn(METHOD_ALIAS, methodInternal)\r\n        ? METHOD_ALIAS[methodInternal as keyof typeof METHOD_ALIAS]\r\n        : methodInternal;\r\n    assert(hasOwn(METHOD_INTERNAL, methodInternal), `Illegal method ${method}.`);\r\n    return methodInternal;\r\n}\r\n\r\n\r\n\r\ntype CollectionResultLine = number[];\r\n\r\nconst createCollectionResultLine: CreateInTravel<CollectionResultLine> = (\r\n    upstream, dataIndex, collectionDimInfoList, groupByDimInfo, groupByVal\r\n) => {\r\n    const newLine = [] as number[];\r\n    for (let i = 0; i < collectionDimInfoList.length; i++) {\r\n        const dimInfo = collectionDimInfoList[i];\r\n        const collectionInfoList = dimInfo.collectionInfoList;\r\n        for (let j = 0; j < collectionInfoList.length; j++) {\r\n            const collectionInfo = collectionInfoList[j];\r\n            // FIXME: convert to number compulsorily temporarily.\r\n            newLine[collectionInfo.indexInLine] = +lineCreator[collectionInfo.method](\r\n                upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal\r\n            );\r\n        }\r\n        // FIXME: refactor\r\n        if (dimInfo.needGatherValues) {\r\n            const val = upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\r\n            dimInfo.gatherValue(groupByDimInfo, groupByVal, val);\r\n        }\r\n    }\r\n    return newLine;\r\n};\r\n\r\nconst updateCollectionResultLine: UpdateInTravel<CollectionResultLine> = (\r\n    upstream, dataIndex, targetLine: number[], collectionDimInfoList, groupByDimInfo, groupByVal\r\n) => {\r\n    for (let i = 0; i < collectionDimInfoList.length; i++) {\r\n        const dimInfo = collectionDimInfoList[i];\r\n        const collectionInfoList = dimInfo.collectionInfoList;\r\n        for (let j = 0; j < collectionInfoList.length; j++) {\r\n            const collectionInfo = collectionInfoList[j];\r\n            const indexInLine = collectionInfo.indexInLine;\r\n            // FIXME: convert to number compulsorily temporarily.\r\n            targetLine[indexInLine] = +lineUpdater[collectionInfo.method](\r\n                targetLine[indexInLine], upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal\r\n            );\r\n        }\r\n        // FIXME: refactor\r\n        if (dimInfo.needGatherValues) {\r\n            const val = upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\r\n            dimInfo.gatherValue(groupByDimInfo, groupByVal, val);\r\n        }\r\n    }\r\n};\r\n\r\n\r\n\r\ntype FinalResultLine = OptionDataValue[];\r\n\r\nconst createFinalResultLine: CreateInTravel<FinalResultLine> = (\r\n    upstream, dataIndex, finalResultDimInfoList, groupByDimInfo, groupByVal\r\n) => {\r\n    const newLine = [];\r\n    for (let i = 0; i < finalResultDimInfoList.length; i++) {\r\n        const dimInfo = finalResultDimInfoList[i];\r\n        const method = dimInfo.method;\r\n        newLine[i] = isGroupByDimension(groupByDimInfo, dimInfo)\r\n            ? groupByVal\r\n            : lineCreator[method](\r\n                upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal\r\n            );\r\n    }\r\n    return newLine;\r\n};\r\n\r\nconst updateFinalResultLine: UpdateInTravel<FinalResultLine> = (\r\n    upstream, dataIndex, targetLine, finalResultDimInfoList, groupByDimInfo, groupByVal\r\n) => {\r\n    for (let i = 0; i < finalResultDimInfoList.length; i++) {\r\n        const dimInfo = finalResultDimInfoList[i];\r\n        if (isGroupByDimension(groupByDimInfo, dimInfo)) {\r\n            continue;\r\n        }\r\n        const method = dimInfo.method;\r\n        targetLine[i] = lineUpdater[method](\r\n            targetLine[i], upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal\r\n        );\r\n    }\r\n};\r\n\r\nfunction isGroupByDimension(\r\n    groupByDimInfo: ExternalDimensionDefinition,\r\n    targetDimInfo: ResultDimInfoInternal\r\n): boolean {\r\n    return groupByDimInfo && targetDimInfo.indexInUpstream === groupByDimInfo.index;\r\n}\r\n\r\nfunction asc(list: number[]) {\r\n    list.sort((a, b) => {\r\n        return a - b;\r\n    });\r\n}\r\n\r\nconst lineCreator: {\r\n    [key in AggregateMethodInternal]: (\r\n        upstream: ExternalSource,\r\n        dataIndex: number,\r\n        dimInfo: ResultDimInfoInternal,\r\n        groupByDimInfo: ExternalDimensionDefinition,\r\n        groupByVal: OptionDataValue\r\n    ) => OptionDataValue\r\n} = {\r\n    'SUM'(upstream, dataIndex, dimInfo) {\r\n        return upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\r\n    },\r\n    'COUNT'() {\r\n        return 1;\r\n    },\r\n    'FIRST'(upstream, dataIndex, dimInfo) {\r\n        return upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\r\n    },\r\n    'MIN'(upstream, dataIndex, dimInfo) {\r\n        return upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\r\n    },\r\n    'MAX'(upstream, dataIndex, dimInfo) {\r\n        return upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\r\n    },\r\n    'AVERAGE'(upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\r\n        // FIXME: refactor, bad implementation.\r\n        const collectLine = groupByDimInfo\r\n            ? dimInfo.__collectionResult.mapByGroup[groupByVal + '']\r\n            : dimInfo.__collectionResult.outList[0];\r\n        return (upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number)\r\n            / collectLine[dimInfo.getCollectionInfo('COUNT').indexInLine];\r\n    },\r\n    // FIXME: refactor\r\n    'Q1'(upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\r\n        return lineCreatorForQ(0.25, dimInfo, groupByDimInfo, groupByVal);\r\n    },\r\n    'Q2'(upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\r\n        return lineCreatorForQ(0.5, dimInfo, groupByDimInfo, groupByVal);\r\n    },\r\n    'Q3'(upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\r\n        return lineCreatorForQ(0.75, dimInfo, groupByDimInfo, groupByVal);\r\n    }\r\n};\r\n\r\nconst lineUpdater: {\r\n    [key in AggregateMethodInternal]: (\r\n        val: OptionDataValue,\r\n        upstream: ExternalSource,\r\n        dataIndex: number,\r\n        dimInfo: ResultDimInfoInternal,\r\n        groupByDimInfo: ExternalDimensionDefinition,\r\n        groupByVal: OptionDataValue\r\n    ) => OptionDataValue\r\n} = {\r\n    'SUM'(val, upstream, dataIndex, dimInfo) {\r\n        // FIXME: handle other types\r\n        return (val as number) + (upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number);\r\n    },\r\n    'COUNT'(val) {\r\n        return (val as number) + 1;\r\n    },\r\n    'FIRST'(val) {\r\n        return val;\r\n    },\r\n    'MIN'(val, upstream, dataIndex, dimInfo) {\r\n        return Math.min(val as number, upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number);\r\n    },\r\n    'MAX'(val, upstream, dataIndex, dimInfo) {\r\n        return Math.max(val as number, upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number);\r\n    },\r\n    'AVERAGE'(val, upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\r\n        // FIXME: refactor, bad implementation.\r\n        const collectLine = groupByDimInfo\r\n            ? dimInfo.__collectionResult.mapByGroup[groupByVal + '']\r\n            : dimInfo.__collectionResult.outList[0];\r\n        return (val as number)\r\n            + (upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number)\r\n            / collectLine[dimInfo.getCollectionInfo('COUNT').indexInLine];\r\n    },\r\n    'Q1'(val, upstream, dataIndex, dimInfo) {\r\n        return val;\r\n    },\r\n    'Q2'(val, upstream, dataIndex, dimInfo) {\r\n        return val;\r\n    },\r\n    'Q3'(val, upstream, dataIndex, dimInfo) {\r\n        return val;\r\n    }\r\n};\r\n\r\nfunction lineCreatorForQ(\r\n    percent: number,\r\n    dimInfo: ResultDimInfoInternal,\r\n    groupByDimInfo: ExternalDimensionDefinition,\r\n    groupByVal: OptionDataValue\r\n) {\r\n    const gatheredValues = groupByDimInfo\r\n        ? dimInfo.gatheredValuesByGroup[groupByVal + '']\r\n        : dimInfo.gatheredValuesNoGroup;\r\n    return quantile(gatheredValues, percent);\r\n}\r\n","import {\r\n    DataTransformOption, DimensionLoose, DimensionName, DimensionIndex, ExternalDataTransform,\r\n    ExternalDimensionDefinition, ExternalSource, OptionDataValue, OptionSourceDataArrayRows\r\n} from './types';\r\n\r\nexport interface MapTransformOption extends DataTransformOption {\r\n    type: 'ecSimpleTransform:map';\r\n    config: {\r\n        // Mandatory\r\n        resultDimensions: {\r\n            // Optional. The name of the result dimensions.\r\n            // If not provided, inherit the name from `from`.\r\n            name: DimensionName;\r\n            // Mandatory. `from` is used to reference dimension from `source`.\r\n            from: DimensionIndex;\r\n            // Optional. Map function to apply to the dimension.\r\n            method: Function;\r\n        }[];\r\n    \r\n    };\r\n}\r\n\r\n// Echart transform to apply a map function to  a dimension\r\nexport const transform: ExternalDataTransform<MapTransformOption> = {\r\n\r\n    type: 'ecSimpleTransform:map',\r\n\r\n    transform: function (params) {\r\n        const upstream = params.upstream;\r\n        const config = params.config;\r\n        const resultDimensions = config.resultDimensions;\r\n\r\n        const dimsDef = upstream.cloneAllDimensionInfo() as ExternalDimensionDefinition[];\r\n\r\n        const data = upstream.cloneRawData() as OptionSourceDataArrayRows;\r\n        const resultData: OptionSourceDataArrayRows = [];\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n            const dataItem = data[i];\r\n            const resultDataItem: OptionSourceDataArrayRows[number] = [];\r\n            for (let j = 0; j < resultDimensions.length; j++) {\r\n                const resultDimension = resultDimensions[j];\r\n                const fromDimension = resultDimension.from;\r\n                const method = resultDimension.method;\r\n                const value = dataItem[fromDimension];\r\n                const resultValue = method(value);\r\n                resultDataItem.push(resultValue);\r\n            }\r\n            resultData.push(resultDataItem);\r\n        }\r\n\r\n        return {\r\n            dimensions: dimsDef,\r\n            data: resultData,\r\n\r\n        };\r\n    }\r\n};\r\n"],"names":["transform"],"mappings":";;;;;;QAgEa,SAAS,GAA6C;QAE/D,IAAI,EAAE,sBAAsB;QAE5B,SAAS,EAAE,UAAU,MAAM;YACvB,IAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;YACjC,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;YAC7B,IAAM,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;YAC7C,IAAM,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;YAE3C,IAAM,OAAO,GAAG,QAAQ,CAAC,qBAAqB,EAAgC,CAAC;YAC/E,OAAO,CAAC,cAAc,CAAC,GAAG,aAAa,CAAC;YAExC,IAAM,IAAI,GAAG,QAAQ,CAAC,YAAY,EAA+B,CAAC;YAGlE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBAC7C,IAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;aAC5B;YAED,OAAO;gBACH,UAAU,EAAE,OAAO;gBACnB,IAAI,EAAE,IAAI;aACb,CAAC;SACL;;;aCtEW,MAAM,CAAC,SAAc,EAAE,OAAgB;QACnD,IAAI,CAAC,SAAS,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;SAC5B;IACL,CAAC;aAEe,MAAM,CAAC,GAAW,EAAE,IAAY;QAC5C,OAAO,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;aAEe,QAAQ,CAAC,MAAgB,EAAE,CAAS;QAChD,IAAM,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACtC,IAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACxB,IAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACzB,IAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAChB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IAC3C;;ICgDA,IAAM,eAAe,GAAG;QACpB,KAAK,EAAE,IAAI;QACX,OAAO,EAAE,IAAI;QACb,OAAO,EAAE,IAAI;QACb,SAAS,EAAE,IAAI;QACf,IAAI,EAAE,IAAI;QACV,IAAI,EAAE,IAAI;QACV,IAAI,EAAE,IAAI;QACV,KAAK,EAAE,IAAI;QACX,KAAK,EAAE,IAAI;KACL,CAAC;IACX,IAAM,oBAAoB,GAAG;QACzB,OAAO,EAAE,CAAC,OAAO,CAAC;KACZ,CAAC;IACX,IAAM,0BAA0B,GAAG;QAC/B,EAAE,EAAE,IAAI;QACR,EAAE,EAAE,IAAI;QACR,EAAE,EAAE,IAAI;KACF,CAAC;IACX,IAAM,YAAY,GAAG;QACjB,MAAM,EAAE,IAAI;KACN,CAAC;IAQX;QAwBI,+BACI,KAAa,EACb,eAAuB,EACvB,MAA+B,EAC/B,IAAmB,EACnB,gBAAyB;YAtBpB,uBAAkB,GAAG,EAG3B,CAAC;YAGK,0BAAqB,GAAqC,EAAE,CAAC;YAC7D,0BAAqB,GAAG,EAAc,CAAC;YACvC,qBAAgB,GAAY,KAAK,CAAC;YAInC,uBAAkB,GAAG,EAG5B,CAAC;YASE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;YACnB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;YACvC,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;SAC5C;QAED,iDAAiB,GAAjB,UAAkB,IAAyD;YACvE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC;YACtE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACtC;QAED,iDAAiB,GAAjB,UAAkB,MAA+B;YAC7C,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC;SACnE;QAGD,2CAAW,GAAX,UAAY,cAA2C,EAAE,QAAyB,EAAE,KAAsB;YAEtG,KAAK,GAAG,CAAC,KAAK,CAAC;YACf,IAAI,cAAc,EAAE;gBAChB,IAAI,QAAQ,IAAI,IAAI,EAAE;oBAClB,IAAM,WAAW,GAAG,QAAQ,GAAG,EAAE,CAAC;oBAClC,IAAM,MAAM,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC;4BAC9C,IAAI,CAAC,qBAAqB,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,CAAC;oBACtD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACtB;aACJ;iBACI;gBACD,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAC1C;SACJ;QACL,4BAAC;IAAD,CAAC,IAAA;QAkBYA,WAAS,GAAoD;QAEtE,IAAI,EAAE,6BAA6B;QAEnC,SAAS,EAAE,UAAU,MAAM;YACvB,IAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;YACjC,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;YAE7B,IAAM,cAAc,GAAG,qBAAqB,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;YACzD,IAAA,KAAoD,iBAAiB,CACvE,MAAM,EAAE,QAAQ,EAAE,cAAc,CACnC,EAFO,sBAAsB,4BAAA,EAAE,qBAAqB,2BAEpD,CAAC;YAGF,IAAI,gBAAoD,CAAC;YACzD,IAAI,qBAAqB,CAAC,MAAM,EAAE;gBAC9B,gBAAgB,GAAG,MAAM,CACrB,cAAc,EACd,QAAQ,EACR,qBAAqB,EACrB,0BAA0B,EAC1B,0BAA0B,CAC7B,CAAC;aACL;YAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACnD,IAAM,OAAO,GAAG,qBAAqB,CAAC,CAAC,CAAC,CAAC;gBACzC,OAAO,CAAC,kBAAkB,GAAG,gBAAgB,CAAC;gBAE9C,GAAG,CAAC,OAAO,CAAC,qBAAqB,CAAC,CAAC;gBAEnC,IAAM,qBAAqB,GAAG,OAAO,CAAC,qBAAqB,CAAC;gBAC5D,KAAK,IAAM,GAAG,IAAI,qBAAqB,EAAE;oBACrC,IAAI,MAAM,CAAC,qBAAqB,EAAE,GAAG,CAAC,EAAE;wBACpC,GAAG,CAAC,qBAAqB,CAAC,GAAG,CAAC,CAAC,CAAC;qBACnC;iBACJ;aACJ;YAGD,IAAM,WAAW,GAAG,MAAM,CACtB,cAAc,EACd,QAAQ,EACR,sBAAsB,EACtB,qBAAqB,EACrB,qBAAqB,CACxB,CAAC;YAEF,IAAM,UAAU,GAAG,EAAE,CAAC;YACtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,sBAAsB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACpD,UAAU,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;aACnD;YAED,OAAO;gBACH,UAAU,EAAE,UAAU;gBACtB,IAAI,EAAE,WAAW,CAAC,OAAO;aAC5B,CAAC;SACL;MACH;IAEF,SAAS,iBAAiB,CACtB,MAA0C,EAC1C,QAAwB,EACxB,cAA2C;QAK3C,IAAM,sBAAsB,GAAG,MAAM,CAAC,gBAAgB,CAAC;QACvD,IAAM,sBAAsB,GAA4B,EAAE,CAAC;QAC3D,IAAM,qBAAqB,GAA4B,EAAE,CAAC;QAC1D,IAAI,YAAY,GAAG,CAAC,CAAC;QAErB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,sBAAsB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACpD,IAAM,mBAAmB,GAAG,sBAAsB,CAAC,CAAC,CAAC,CAAC;YAEtD,IAAM,iBAAiB,GAAG,QAAQ,CAAC,gBAAgB,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAC9E,MAAM,CAAC,iBAAiB,EAAE,oCAAoC,GAAG,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAE3F,IAAM,SAAS,GAAG,mBAAmB,CAAC,MAAM,CAAC;YAE7C,MAAM,CACF,cAAc,CAAC,KAAK,KAAK,iBAAiB,CAAC,KAAK,IAAI,SAAS,IAAI,IAAI,EACrE,oBAAa,iBAAiB,CAAC,IAAI,iEAA0D,CAChG,CAAC;YAEF,IAAM,MAAM,GAAG,eAAe,CAAC,SAAS,CAAC,CAAC;YAC1C,MAAM,CAAC,MAAM,EAAE,oBAAoB,CAAC,CAAC;YAErC,IAAM,MAAI,GAAG,mBAAmB,CAAC,IAAI,IAAI,IAAI,GAAG,mBAAmB,CAAC,IAAI,GAAG,iBAAiB,CAAC,IAAI,CAAC;YAElG,IAAM,kBAAkB,GAAG,IAAI,qBAAqB,CAChD,sBAAsB,CAAC,MAAM,EAC7B,iBAAiB,CAAC,KAAK,EACvB,MAAM,EACN,MAAI,EACJ,MAAM,CAAC,0BAA0B,EAAE,MAAM,CAAC,CAC7C,CAAC;YACF,sBAAsB,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YAGhD,IAAI,WAAW,GAAG,KAAK,CAAC;YACxB,IAAI,MAAM,CAAC,oBAAoB,EAAE,MAAM,CAAC,EAAE;gBACtC,WAAW,GAAG,IAAI,CAAC;gBACnB,IAAM,uBAAuB,GAAG,oBAAoB,CAAC,MAA2C,CAAC,CAAC;gBAClG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,uBAAuB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACrD,kBAAkB,CAAC,iBAAiB,CAAC;wBACjC,MAAM,EAAE,uBAAuB,CAAC,CAAC,CAAC;wBAClC,WAAW,EAAE,YAAY,EAAE;qBAC9B,CAAC,CAAC;iBACN;aACJ;YACD,IAAI,MAAM,CAAC,0BAA0B,EAAE,MAAM,CAAC,EAAE;gBAC5C,WAAW,GAAG,IAAI,CAAC;aACtB;YACD,IAAI,WAAW,EAAE;gBACb,qBAAqB,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;aAClD;SACJ;QAED,OAAO,EAAE,qBAAqB,uBAAA,EAAE,sBAAsB,wBAAA,EAAE,CAAC;IAC7D,CAAC;IAED,SAAS,qBAAqB,CAC1B,MAA0C,EAC1C,QAAwB;QAExB,IAAM,aAAa,GAAG,MAAM,CAAC,OAAO,CAAC;QACrC,IAAI,cAAc,CAAC;QACnB,IAAI,aAAa,IAAI,IAAI,EAAE;YACvB,cAAc,GAAG,QAAQ,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;YAC1D,MAAM,CAAC,cAAc,EAAE,uCAAuC,GAAG,aAAa,CAAC,CAAC;SACnF;QACD,OAAO,cAAc,CAAC;IAC1B,CAAC;IAOD,SAAS,MAAM,CACX,cAA2C,EAC3C,QAAwB,EACxB,iBAA0C,EAC1C,QAA8B,EAC9B,QAA8B;QAE9B,IAAM,OAAO,GAAkC,EAAE,CAAC;QAClD,IAAI,UAA4C,CAAC;QAEjD,IAAI,cAAc,EAAE;YAChB,UAAU,GAAG,EAAE,CAAC;YAEhB,KAAK,IAAI,SAAS,GAAG,CAAC,EAAE,GAAG,GAAG,QAAQ,CAAC,KAAK,EAAE,EAAE,SAAS,GAAG,GAAG,EAAE,SAAS,EAAE,EAAE;gBAC1E,IAAM,UAAU,GAAG,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;gBAG3E,IAAI,UAAU,IAAI,IAAI,EAAE;oBACpB,SAAS;iBACZ;gBAED,IAAM,aAAa,GAAG,UAAU,GAAG,EAAE,CAAC;gBAEtC,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,aAAa,CAAC,EAAE;oBACpC,IAAM,OAAO,GAAG,QAAQ,CAAC,QAAQ,EAAE,SAAS,EAAE,iBAAiB,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;oBAC7F,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;oBACtB,UAAU,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC;iBACvC;qBACI;oBACD,IAAM,UAAU,GAAG,UAAU,CAAC,aAAa,CAAC,CAAC;oBAC7C,QAAQ,CAAC,QAAQ,EAAE,SAAS,EAAE,UAAU,EAAE,iBAAiB,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;iBAC5F;aACJ;SACJ;aACI;YACD,IAAM,UAAU,GAAG,QAAQ,CAAC,QAAQ,EAAE,CAAC,EAAE,iBAAiB,CAAC,CAAC;YAC5D,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACzB,KAAK,IAAI,SAAS,GAAG,CAAC,EAAE,GAAG,GAAG,QAAQ,CAAC,KAAK,EAAE,EAAE,SAAS,GAAG,GAAG,EAAE,SAAS,EAAE,EAAE;gBAC1E,QAAQ,CAAC,QAAQ,EAAE,SAAS,EAAE,UAAU,EAAE,iBAAiB,CAAC,CAAC;aAChE;SACJ;QAED,OAAO,EAAE,UAAU,YAAA,EAAE,OAAO,SAAA,EAAE,CAAC;IACnC,CAAC;IAED,SAAS,eAAe,CAAC,MAA4B;QACjD,IAAI,MAAM,IAAI,IAAI,EAAE;YAChB,OAAO,OAAO,CAAC;SAClB;QACD,IAAI,cAAc,GAAG,MAAM,CAAC,WAAW,EAA6B,CAAC;QACrE,cAAc,GAAG,MAAM,CAAC,YAAY,EAAE,cAAc,CAAC;cAC/C,YAAY,CAAC,cAA2C,CAAC;cACzD,cAAc,CAAC;QACrB,MAAM,CAAC,MAAM,CAAC,eAAe,EAAE,cAAc,CAAC,EAAE,yBAAkB,MAAM,MAAG,CAAC,CAAC;QAC7E,OAAO,cAAc,CAAC;IAC1B,CAAC;IAMD,IAAM,0BAA0B,GAAyC,UACrE,QAAQ,EAAE,SAAS,EAAE,qBAAqB,EAAE,cAAc,EAAE,UAAU;QAEtE,IAAM,OAAO,GAAG,EAAc,CAAC;QAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnD,IAAM,OAAO,GAAG,qBAAqB,CAAC,CAAC,CAAC,CAAC;YACzC,IAAM,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,kBAAkB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAChD,IAAM,cAAc,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC;gBAE7C,OAAO,CAAC,cAAc,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,cAAc,CAAC,MAAM,CAAC,CACrE,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU,CAC3D,CAAC;aACL;YAED,IAAI,OAAO,CAAC,gBAAgB,EAAE;gBAC1B,IAAM,GAAG,GAAG,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;gBACvE,OAAO,CAAC,WAAW,CAAC,cAAc,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC;aACxD;SACJ;QACD,OAAO,OAAO,CAAC;IACnB,CAAC,CAAC;IAEF,IAAM,0BAA0B,GAAyC,UACrE,QAAQ,EAAE,SAAS,EAAE,UAAoB,EAAE,qBAAqB,EAAE,cAAc,EAAE,UAAU;QAE5F,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnD,IAAM,OAAO,GAAG,qBAAqB,CAAC,CAAC,CAAC,CAAC;YACzC,IAAM,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,kBAAkB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAChD,IAAM,cAAc,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC;gBAC7C,IAAM,WAAW,GAAG,cAAc,CAAC,WAAW,CAAC;gBAE/C,UAAU,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,cAAc,CAAC,MAAM,CAAC,CACzD,UAAU,CAAC,WAAW,CAAC,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU,CACpF,CAAC;aACL;YAED,IAAI,OAAO,CAAC,gBAAgB,EAAE;gBAC1B,IAAM,GAAG,GAAG,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;gBACvE,OAAO,CAAC,WAAW,CAAC,cAAc,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC;aACxD;SACJ;IACL,CAAC,CAAC;IAMF,IAAM,qBAAqB,GAAoC,UAC3D,QAAQ,EAAE,SAAS,EAAE,sBAAsB,EAAE,cAAc,EAAE,UAAU;QAEvE,IAAM,OAAO,GAAG,EAAE,CAAC;QACnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,sBAAsB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACpD,IAAM,OAAO,GAAG,sBAAsB,CAAC,CAAC,CAAC,CAAC;YAC1C,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;YAC9B,OAAO,CAAC,CAAC,CAAC,GAAG,kBAAkB,CAAC,cAAc,EAAE,OAAO,CAAC;kBAClD,UAAU;kBACV,WAAW,CAAC,MAAM,CAAC,CACjB,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU,CAC3D,CAAC;SACT;QACD,OAAO,OAAO,CAAC;IACnB,CAAC,CAAC;IAEF,IAAM,qBAAqB,GAAoC,UAC3D,QAAQ,EAAE,SAAS,EAAE,UAAU,EAAE,sBAAsB,EAAE,cAAc,EAAE,UAAU;QAEnF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,sBAAsB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACpD,IAAM,OAAO,GAAG,sBAAsB,CAAC,CAAC,CAAC,CAAC;YAC1C,IAAI,kBAAkB,CAAC,cAAc,EAAE,OAAO,CAAC,EAAE;gBAC7C,SAAS;aACZ;YACD,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;YAC9B,UAAU,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,MAAM,CAAC,CAC/B,UAAU,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU,CAC1E,CAAC;SACL;IACL,CAAC,CAAC;IAEF,SAAS,kBAAkB,CACvB,cAA2C,EAC3C,aAAoC;QAEpC,OAAO,cAAc,IAAI,aAAa,CAAC,eAAe,KAAK,cAAc,CAAC,KAAK,CAAC;IACpF,CAAC;IAED,SAAS,GAAG,CAAC,IAAc;QACvB,IAAI,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;YACX,OAAO,CAAC,GAAG,CAAC,CAAC;SAChB,CAAC,CAAC;IACP,CAAC;IAED,IAAM,WAAW,GAQb;QACA,KAAK,YAAC,QAAQ,EAAE,SAAS,EAAE,OAAO;YAC9B,OAAO,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;SACrE;QACD,OAAO;YACH,OAAO,CAAC,CAAC;SACZ;QACD,OAAO,YAAC,QAAQ,EAAE,SAAS,EAAE,OAAO;YAChC,OAAO,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;SACrE;QACD,KAAK,YAAC,QAAQ,EAAE,SAAS,EAAE,OAAO;YAC9B,OAAO,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;SACrE;QACD,KAAK,YAAC,QAAQ,EAAE,SAAS,EAAE,OAAO;YAC9B,OAAO,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;SACrE;QACD,SAAS,YAAC,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU;YAE9D,IAAM,WAAW,GAAG,cAAc;kBAC5B,OAAO,CAAC,kBAAkB,CAAC,UAAU,CAAC,UAAU,GAAG,EAAE,CAAC;kBACtD,OAAO,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC5C,OAAQ,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAY;kBACvE,WAAW,CAAC,OAAO,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,WAAW,CAAC,CAAC;SACrE;QAED,IAAI,YAAC,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU;YACzD,OAAO,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;SACrE;QACD,IAAI,YAAC,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU;YACzD,OAAO,eAAe,CAAC,GAAG,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;SACpE;QACD,IAAI,YAAC,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU;YACzD,OAAO,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;SACrE;KACJ,CAAC;IAEF,IAAM,WAAW,GASb;QACA,KAAK,YAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO;YAEnC,OAAQ,GAAc,GAAI,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAY,CAAC;SACnG;QACD,OAAO,YAAC,GAAG;YACP,OAAQ,GAAc,GAAG,CAAC,CAAC;SAC9B;QACD,OAAO,YAAC,GAAG;YACP,OAAO,GAAG,CAAC;SACd;QACD,KAAK,YAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO;YACnC,OAAO,IAAI,CAAC,GAAG,CAAC,GAAa,EAAE,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAW,CAAC,CAAC;SACxG;QACD,KAAK,YAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO;YACnC,OAAO,IAAI,CAAC,GAAG,CAAC,GAAa,EAAE,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAW,CAAC,CAAC;SACxG;QACD,SAAS,YAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU;YAEnE,IAAM,WAAW,GAAG,cAAc;kBAC5B,OAAO,CAAC,kBAAkB,CAAC,UAAU,CAAC,UAAU,GAAG,EAAE,CAAC;kBACtD,OAAO,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC5C,OAAQ,GAAc;kBACf,QAAQ,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAAC,eAAe,CAAY;sBACtE,WAAW,CAAC,OAAO,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,WAAW,CAAC,CAAC;SACrE;QACD,IAAI,YAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO;YAClC,OAAO,GAAG,CAAC;SACd;QACD,IAAI,YAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO;YAClC,OAAO,GAAG,CAAC;SACd;QACD,IAAI,YAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAO;YAClC,OAAO,GAAG,CAAC;SACd;KACJ,CAAC;IAEF,SAAS,eAAe,CACpB,OAAe,EACf,OAA8B,EAC9B,cAA2C,EAC3C,UAA2B;QAE3B,IAAM,cAAc,GAAG,cAAc;cAC/B,OAAO,CAAC,qBAAqB,CAAC,UAAU,GAAG,EAAE,CAAC;cAC9C,OAAO,CAAC,qBAAqB,CAAC;QACpC,OAAO,QAAQ,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;IAC7C;;QCrjBaA,WAAS,GAA8C;QAEhE,IAAI,EAAE,uBAAuB;QAE7B,SAAS,EAAE,UAAU,MAAM;YACvB,IAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;YACjC,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;YAC7B,IAAM,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC;YAEjD,IAAM,OAAO,GAAG,QAAQ,CAAC,qBAAqB,EAAmC,CAAC;YAElF,IAAM,IAAI,GAAG,QAAQ,CAAC,YAAY,EAA+B,CAAC;YAClE,IAAM,UAAU,GAA8B,EAAE,CAAC;YAEjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAClC,IAAM,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACzB,IAAM,cAAc,GAAsC,EAAE,CAAC;gBAC7D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC9C,IAAM,eAAe,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;oBAC5C,IAAM,aAAa,GAAG,eAAe,CAAC,IAAI,CAAC;oBAC3C,IAAM,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;oBACtC,IAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAC;oBACtC,IAAM,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;oBAClC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;iBACpC;gBACD,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;aACnC;YAED,OAAO;gBACH,UAAU,EAAE,OAAO;gBACnB,IAAI,EAAE,UAAU;aAEnB,CAAC;SACL;;;;;;;;;;;;;"}